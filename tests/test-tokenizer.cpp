#include "bark.h"

#include <cstdio>
#include <string>
#include <map>
#include <vector>

static const std::map<std::string, std::vector<bark_vocab::id>> & k_tests()
{
    static std::map<std::string, std::vector<bark_vocab::id>> _k_tests = {
        { "Hello World!",                              { 31178, 11356,   106,                                                                       }, },
        { "Hello World",                               { 31178, 11356,                                                                              }, },
        { " Hello World!",                             { 31178, 11356,   106,                                                                       }, },
        { "this is an audio generated by bark",        { 10531, 10124, 10151, 23685, 48918, 10155, 18121, 10174,                                    }, },
        { "l'Amérique si c'est un rêve je le saurai ", {   180,   112, 28426, 10294,   171,   112, 10176, 10119, 89952, 10144, 10141, 11731, 33186, }, },
    };
    return _k_tests;
};

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <model-file>\n", argv[0]);
        return 1;
    }

    const std::string fname = argv[1];

    fprintf(stderr, "%s : reading vocab from: '%s'\n", __func__, fname.c_str());

    bark_model model;

    // load text model and vocab
    {
        if(!gpt_model_load(fname, model.text_model, model.vocab, true)) {
            fprintf(stderr, "%s: invalid model file '%s' (bad text)\n", __func__, fname.c_str());
            return 1;
        }
        model.memsize += model.text_model.memsize;
    }

    for (const auto & test_kv : k_tests()) {
        std::vector<bark_vocab::id> res(test_kv.first.size());
        int n_tokens;
        bert_tokenize(model.vocab, test_kv.first.c_str(), res.data(), &n_tokens, true);
        res.resize(n_tokens);

        bool correct = res.size() == test_kv.second.size();

        for (int i = 0; i < (int) res.size() && correct; ++i) {
            if (res[i] != test_kv.second[i]) {
                correct = false;
            }
        }

        if (!correct) {
            fprintf(stderr, "%s : failed test: '%s'\n", __func__, test_kv.first.c_str());
            fprintf(stderr, "%s : expected tokens: ", __func__);
            for (const auto & t : test_kv.second) {
                fprintf(stderr, "%6d, ", t);
            }
            fprintf(stderr, "\n");
            fprintf(stderr, "%s : got tokens:      ", __func__);
            for (const auto & t : res) {
                fprintf(stderr, "%6d, ", t);
            }
            fprintf(stderr, "\n");

            return 3;
        }
    }

    ggml_free(model.coarse_model.ctx);
    ggml_free(model.fine_model.ctx);
    ggml_free(model.text_model.ctx);
    ggml_free(model.codec_model.ctx);

    return 0;
}
